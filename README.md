# QR Code Generator

## Database Integration

The MongoDB is used to save all the data about QR-codes. The application connects to a MongoDB database to store and manage data. MongoDB is a popular NoSQL database known for its flexibility and scalability.

## QRCode Model

The QRCode entity represents a QR code generated by the user. It has the following properties:

- `name`: A string that represents the name of the QR code.
- `link`: A string that represents the data encoded in the QR code.
- `important`: A boolean that indicates whether the QR code is marked as important.
- `image`: A string that represents the QR code image in Data URL format.

## Endpoints

Here are some of the endpoints that interact with these entities:

- `POST /generate-qr`: Generates a new QR code. The request body should include the name, link, and important properties.
- `GET /qrcodes`: Returns a list of all QR codes.
- `GET /display-qr/:id`: Returns a specific QR code.
- `POST /update-qr/:id`: Updates a specific QR code. The request body should include the new name and important properties.
- `DELETE /delete-qr/:id`: Deletes a specific QR code.

## Additional Functionalities

### Caching Strategies Documentation
### Cache Implementation

The cache is initiated using the `node-cache` library, creating a new instance of `NodeCache`. The configuration includes settings for the standard Time-To-Live (TTL) and the check period for expired items.

```javascript
// helpers/cache.js

const NodeCache = require('node-cache');
const myCache = new NodeCache({ stdTTL: 60 * 60, checkperiod: 120 });
module.exports = { myCache };
```

- `stdTTL: 60 * 60`: Sets the standard Time-To-Live for each cache item to 1 hour (60 seconds * 60 minutes).
- `checkperiod: 120`: Configures the cache to check for expired items every 2 minutes (120 seconds).

### Cache Usage

#### Storing Data in the Cache

In the `findDataHandler` function, data is retrieved from the cache. If not found, it is generated, and then stored in the cache for future use.

```javascript
// controllers/CodeController.js

const key = 'displayDataStructure';
const value = myCache.get(key);

if (value == undefined) {
    // ... (existing code)
    myCache.set(key, html);
} else {
    res.send(value);
}
```

- `myCache.get(key)`: Retrieves the value associated with the specified key from the cache.
- `myCache.set(key, html)`: Stores the HTML data in the cache with the specified key.

#### Cache Expiry (TTL)

The `stdTTL` parameter in the cache initialization determines how long an item is kept in the cache. In this case, it is set to 1 hour (60 seconds * 60 minutes).

```javascript
// helpers/cache.js

const myCache = new NodeCache({ stdTTL: 60 * 60, checkperiod: 120 });
```

### Cache Invalidation

Cache invalidation is handled automatically by the TTL mechanism. Expired items are removed from the cache during the periodic check.


### Analysis of Caching Strategy

#### 1. **Reduced Response Time:**
   - Caching HTML content in the `findDataHandler` function allows the application to serve pre-rendered content from the cache instead of regenerating it for every request.
   - This significantly reduces the response time for clients, especially for frequently accessed pages.

#### 2. **Improved Scalability:**
   - By storing frequently requested HTML content in the cache, the application reduces the load on the server and database.
   - Improved scalability is achieved as the server can handle more concurrent users without a proportional increase in resource utilization.

#### 3. **Enhanced User Experience:**
   - Caching allows the application to respond quickly to user requests, providing a more seamless and responsive user experience.
   - Users benefit from faster page loads and reduced waiting times, contributing to a positive overall experience.

#### 4. **Bandwidth Savings:**
   - Serving pre-cached HTML content reduces the amount of data transferred over the network for repetitive requests.
   - This results in bandwidth savings, particularly beneficial for users with limited or slower internet connections.

#### 5. **Temporary Data Storage:**
   - The cache acts as a temporary data store for HTML content, maintaining the data for a specified Time-To-Live (TTL).
   - This strategy ensures that the cache contains relatively fresh content, balancing the need for performance with data accuracy.

#### 6. **Optimized Server Resources:**
   - Caching helps optimize server resources by offloading repetitive rendering tasks to the cache.
   - Server resources can be allocated more efficiently to handle dynamic or personalized requests.

#### 7. **Consistency in Display Data:**
   - The `findDataHandler` function ensures consistency in displaying data by retrieving pre-rendered content from the cache.
   - Users receive the same version of the display data, minimizing discrepancies across multiple requests.

## Logging and Error Handling Documentation

### Logger Configuration

#### Winston Logger Setup

The application uses Winston as the logging library. The logger is configured to log messages to the console, a combined log file, and an error log file.

```javascript
// helpers/logger.js

const winston = require('winston');

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'combined.log' }),
        new winston.transports.File({ filename: 'error.log', level: 'error' })
    ]
});

module.exports = { logger };
```

### Error Handling Helper

A helper function `handleError` has been introduced to ensure consistent error responses and proper logging. This function is located in the `helpers/errorHandler.js` file.

```javascript
// helpers/errorHandler.js

const { logger } = require('./logger');

function handleError(res, error, statusCode = 500, message = 'Internal Server Error') {
    logger.error(message, error);
    res.status(statusCode).json({ error: message });
}

module.exports = { handleError };
```

#### Log Levels

- **info**: General information about the application's execution.
- **error**: Logs errors that may lead to the application's malfunction.

### CORS

The application is configured to use Cross-Origin Resource Sharing (CORS). This mechanism allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated.

## Functions

The application includes several functions to handle different operations:

- `findDataHandler(req, res)`: This function handles the retrieval of data structure. It uses caching to improve performance.
- `getAllQRCodes(req, res)`: This function retrieves all QR codes from the database.
- `generateQRCode(req, res)`: This function generates a new QR code and saves it to the database.
- `displayQRCode(req, res)`: This function retrieves a specific QR code from the database and displays it.
- `getQRCodeImage(req, res)`: This function retrieves the image of a specific QR code from the database.
- `deleteQR(req, res)`: This function deletes a specific QR code from the database.
- `updateQRCode(req, res)`: This function updates the details of a specific QR code in the database.
- `getUpdatePage(req, res)`: This function retrieves the details of a specific QR code for updating.

These functions are exported as a module for use in other parts of the application.
